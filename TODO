> emit Interval per listener
> delete __arguments prevent memory leakage?
> events -> obj and eventNames -> ['onthis','onthat']
> obj.onSomeEvent().bind(function () {}, { listenCount: N, listenInterval: Y });
  -> spec for a combination of the count and interval 
-> oneTimeEvent is by configuration only
-> does node trigger events callNow or nextTick

> eventify(this, function (events) {
    this === events === this function's this;
    events.namespace('my-events');
    events
      .define('')
      .define('whatevs');
  });

-> eventify(this, function () {
  this.channel('my-channel');
}).define()
  
  
  
> global events
  -> eventify.onAnyEvent(function (eventName, ... other arguments ...) {
      this //is the source
     });
  -> eventify(obj, 'lead-view').define(...)
      eventify.listen('lead-view/onZoom', function () {})
    * namespace optional but use encouraged - if not specified './' is used: './onZoom'
  -> enable/disable event tracing which console.infos every event

-> method to change channel name of and event source.



obj = {}

eventify(obj)
  .define('onSomeEvent')

eventify.onSomeEvent().withInterval(20, function () {
  // behaves like
  // obj.onSomeEvent().throttle(20)
  // obj.onSomeEvent(function () {})
});

eventify(obj, 'socket').define('onSomethingReceived')
obj.onSomethingReceived().emit();

obj.onSomethingReceived(function () {})

eventify.listen('socket/*')


obj.onMouseMoved().withInterval(1234, function listener() {})

DOC:
this is the event source. important because and event should always pass it's source


-> object.onSomeEvent().withInterval(N, listener);
 -> remove throttle() from define() and manager
 -> refactor throttling code


-> eventify(obj).define(...) ... ; obj.eventNames() -> [...]

implemenation good, rename to avoid nodejs events naming collision

> oneTimeEventSpecs dont pass now that it calls back on next tick.
> update the readme (oneTimeEvent, called on next tick after first)
> update version to 0.3.0


var eventSubscription = object.onSomeEvent(function () {

});

var eventSubscription = object.onSomeEvent().once(function () {

});

var eventSubscription = object.onSomeEvent().withInterval(N, function () {

});

eventSubscription.isActive();
eventSubscription.cancel();

var subscriptions = object.onSomeEvent().subscriptions();
subscriptions.cancelAll();

events(this).define('name', options).define().define()
options = {
  emitInterval: ...
}

-> load eventify into the documentation page so that with the console, documentation can be interactive.
-> microjs for inspiration
-> eventify(this).propogateFrom(that, 'onSomeEvent', 'onSomeOtherEvent') (no args implies all)
-> documenting usage: there are many ways to bind/unbind. document ONE api and prefix the rest of the functions with a '_' ???
-> doc tagged errors
